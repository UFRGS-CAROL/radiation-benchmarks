const char *cl_source_scan =
"#ifdef SINGLE_PRECISION\n"
"#define FPTYPE float\n"
"#define FPVECTYPE float4\n"
"#elif K_DOUBLE_PRECISION\n"
"#pragma OPENCL EXTENSION cl_khr_fp64: enable\n"
"#define FPTYPE double\n"
"#define FPVECTYPE double4\n"
"#elif AMD_DOUBLE_PRECISION\n"
"#pragma OPENCL EXTENSION cl_amd_fp64: enable\n"
"#define FPTYPE double\n"
"#define FPVECTYPE double4\n"
"#endif\n"
"\n"
"__kernel void\n"
"reduce(__global const FPTYPE * in,\n"
"       __global FPTYPE * isums,\n"
"       const int n,\n"
"       __local FPTYPE * lmem)\n"
"{\n"
"    // First, calculate the bounds of the region of the array\n"
"    // that this block will sum.  We need these regions to match\n"
"    // perfectly with those in the bottom-level scan, so we index\n"
"    // as if vector types of length 4 were in use.  This prevents\n"
"    // errors due to slightly misaligned regions.\n"
"    int region_size = ((n / 4) / get_num_groups(0)) * 4;\n"
"    int block_start = get_group_id(0) * region_size;\n"
"\n"
"    // Give the last block any extra elements\n"
"    int block_stop  = (get_group_id(0) == get_num_groups(0) - 1) ?\n"
"        n : block_start + region_size;\n"
"\n"
"    // Calculate starting index for this thread/work item\n"
"    int tid = get_local_id(0);\n"
"    int i = block_start + tid;\n"
"\n"
"    FPTYPE sum = 0.0f;\n"
"\n"
"    // Reduce multiple elements per thread\n"
"    while (i < block_stop)\n"
"    {\n"
"        sum += in[i];\n"
"        i += get_local_size(0);\n"
"    }\n"
"    // Load this thread's sum into local/shared memory\n"
"    lmem[tid] = sum;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Reduce the contents of shared/local memory\n"
"    for (unsigned int s = get_local_size(0) / 2; s > 0; s >>= 1)\n"
"    {\n"
"        if (tid < s)\n"
"        {\n"
"            lmem[tid] += lmem[tid + s];\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    // Write result for this block to global memory\n"
"    if (tid == 0)\n"
"    {\n"
"        isums[get_group_id(0)] = lmem[0];\n"
"    }\n"
"}\n"
"\n"
"// This kernel scans the contents of local memory using a work\n"
"// inefficient, but highly parallel Kogge-Stone style scan.\n"
"// Set exclusive to 1 for an exclusive scan or 0 for an inclusive scan\n"
"inline FPTYPE scanLocalMem(FPTYPE val, __local FPTYPE* lmem, int exclusive)\n"
"{\n"
"    // Set first half of local memory to zero to make room for scanning\n"
"    int idx = get_local_id(0);\n"
"    lmem[idx] = 0.0f;\n"
"\n"
"    // Set second half to block sums from global memory, but don't go out\n"
"    // of bounds\n"
"    idx += get_local_size(0);\n"
"    lmem[idx] = val;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Now, perform Kogge-Stone scan\n"
"    FPTYPE t;\n"
"    for (int i = 1; i < get_local_size(0); i *= 2)\n"
"    {\n"
"        t = lmem[idx -  i]; barrier(CLK_LOCAL_MEM_FENCE);\n"
"        lmem[idx] += t;     barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    return lmem[idx-exclusive];\n"
"}\n"
"\n"
"__kernel void\n"
"top_scan(__global FPTYPE * isums, const int n, __local FPTYPE * lmem)\n"
"{\n"
"    FPTYPE val = get_local_id(0) < n ? isums[get_local_id(0)] : 0.0f;\n"
"    val = scanLocalMem(val, lmem, 1);\n"
"\n"
"    if (get_local_id(0) < n)\n"
"    {\n"
"        isums[get_local_id(0)] = val;\n"
"    }\n"
"}\n"
"\n"
"__kernel void\n"
"bottom_scan(__global const FPTYPE * in,\n"
"            __global const FPTYPE * isums,\n"
"            __global FPTYPE * out,\n"
"            const int n,\n"
"            __local FPTYPE * lmem)\n"
"{\n"
"    __local FPTYPE s_seed;\n"
"    s_seed = 0;\n"
"\n"
"    // Prepare for reading 4-element vectors\n"
"    // Assume n is divisible by 4\n"
"    __global FPVECTYPE *in4  = (__global FPVECTYPE*) in;\n"
"    __global FPVECTYPE *out4 = (__global FPVECTYPE*) out;\n"
"    int n4 = n / 4; //vector type is 4 wide\n"
"\n"
"    int region_size = n4 / get_num_groups(0);\n"
"    int block_start = get_group_id(0) * region_size;\n"
"    // Give the last block any extra elements\n"
"    int block_stop  = (get_group_id(0) == get_num_groups(0) - 1) ?\n"
"        n4 : block_start + region_size;\n"
"\n"
"    // Calculate starting index for this thread/work item\n"
"    int i = block_start + get_local_id(0);\n"
"    unsigned int window = block_start;\n"
"\n"
"    // Seed the bottom scan with the results from the top scan (i.e. load the per\n"
"    // block sums from the previous kernel)\n"
"    FPTYPE seed = isums[get_group_id(0)];\n"
"\n"
"    // Scan multiple elements per thread\n"
"    while (window < block_stop) {\n"
"        FPVECTYPE val_4;\n"
"        if (i < block_stop) {\n"
"            val_4 = in4[i];\n"
"        } else {\n"
"            val_4.x = 0.0f;\n"
"            val_4.y = 0.0f;\n"
"            val_4.z = 0.0f;\n"
"            val_4.w = 0.0f;\n"
"        }\n"
"\n"
"        // Serial scan in registers\n"
"        val_4.y += val_4.x;\n"
"        val_4.z += val_4.y;\n"
"        val_4.w += val_4.z;\n"
"\n"
"        // ExScan sums in local memory\n"
"        FPTYPE res = scanLocalMem(val_4.w, lmem, 1);\n"
"\n"
"        // Update and write out to global memory\n"
"        val_4.x += res + seed;\n"
"        val_4.y += res + seed;\n"
"        val_4.z += res + seed;\n"
"        val_4.w += res + seed;\n"
"\n"
"        if (i < block_stop)\n"
"        {\n"
"            out4[i] = val_4;\n"
"        }\n"
"\n"
"        // Next seed will be the last value\n"
"        // Last thread puts seed into smem.\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (get_local_id(0) == get_local_size(0)-1) {\n"
"              s_seed = val_4.w;\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Broadcast seed to other threads\n"
"        seed = s_seed;\n"
"\n"
"        // Advance window\n"
"        window += get_local_size(0);\n"
"        i += get_local_size(0);\n"
"    }\n"
"}\n"
"\n"
;
