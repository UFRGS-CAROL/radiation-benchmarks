const char *kernel_hotspot_ocl =
"#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n"
"\n"
"__kernel void hotspot(  int iteration,  //number of iteration\n"
"                               global float *power,   //power input\n"
"                               global float *temp_src,    //temperature input/output\n"
"                               global float *temp_dst,    //temperature input/output\n"
"                               int grid_cols,  //Col of grid\n"
"                               int grid_rows,  //Row of grid\n"
"							   int border_cols,  // border offset \n"
"							   int border_rows,  // border offset\n"
"                               float Cap,      //Capacitance\n"
"                               float Rx, \n"
"                               float Ry, \n"
"                               float Rz, \n"
"                               float step) {\n"
"	\n"
"	local float temp_on_cuda[BLOCK_SIZE][BLOCK_SIZE];\n"
"	local float power_on_cuda[BLOCK_SIZE][BLOCK_SIZE];\n"
"	local float temp_t[BLOCK_SIZE][BLOCK_SIZE]; // saving temporary temperature result\n"
"\n"
"	float amb_temp = 80.0f;\n"
"	float step_div_Cap;\n"
"	float Rx_1,Ry_1,Rz_1;\n"
"\n"
"	int bx = get_group_id(0);\n"
"	int by = get_group_id(1);\n"
"\n"
"	int tx = get_local_id(0);\n"
"	int ty = get_local_id(1);\n"
"\n"
"	step_div_Cap=step/Cap;\n"
"\n"
"	Rx_1=1/Rx;\n"
"	Ry_1=1/Ry;\n"
"	Rz_1=1/Rz;\n"
"\n"
"	// each block finally computes result for a small block\n"
"	// after N iterations. \n"
"	// it is the non-overlapping small blocks that cover \n"
"	// all the input data\n"
"\n"
"	// calculate the small block size\n"
"	int small_block_rows = BLOCK_SIZE-iteration*2;//EXPAND_RATE\n"
"	int small_block_cols = BLOCK_SIZE-iteration*2;//EXPAND_RATE\n"
"\n"
"	// calculate the boundary for the block according to \n"
"	// the boundary of its small block\n"
"	int blkY = small_block_rows*by-border_rows;\n"
"	int blkX = small_block_cols*bx-border_cols;\n"
"	int blkYmax = blkY+BLOCK_SIZE-1;\n"
"	int blkXmax = blkX+BLOCK_SIZE-1;\n"
"\n"
"	// calculate the global thread coordination\n"
"	int yidx = blkY+ty;\n"
"	int xidx = blkX+tx;\n"
"\n"
"	// load data if it is within the valid input range\n"
"	int loadYidx=yidx, loadXidx=xidx;\n"
"	int index = grid_cols*loadYidx+loadXidx;\n"
"       \n"
"	if(IN_RANGE(loadYidx, 0, grid_rows-1) && IN_RANGE(loadXidx, 0, grid_cols-1)){\n"
"            temp_on_cuda[ty][tx] = temp_src[index];  // Load the temperature data from global memory to shared memory\n"
"            power_on_cuda[ty][tx] = power[index];// Load the power data from global memory to shared memory\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// effective range within this block that falls within \n"
"	// the valid range of the input data\n"
"	// used to rule out computation outside the boundary.\n"
"	int validYmin = (blkY < 0) ? -blkY : 0;\n"
"	int validYmax = (blkYmax > grid_rows-1) ? BLOCK_SIZE-1-(blkYmax-grid_rows+1) : BLOCK_SIZE-1;\n"
"	int validXmin = (blkX < 0) ? -blkX : 0;\n"
"	int validXmax = (blkXmax > grid_cols-1) ? BLOCK_SIZE-1-(blkXmax-grid_cols+1) : BLOCK_SIZE-1;\n"
"\n"
"	int N = ty-1;\n"
"	int S = ty+1;\n"
"	int W = tx-1;\n"
"	int E = tx+1;\n"
"\n"
"	N = (N < validYmin) ? validYmin : N;\n"
"	S = (S > validYmax) ? validYmax : S;\n"
"	W = (W < validXmin) ? validXmin : W;\n"
"	E = (E > validXmax) ? validXmax : E;\n"
"\n"
"	bool computed;\n"
"	for (int i=0; i<iteration ; i++){ \n"
"		computed = false;\n"
"		if( IN_RANGE(tx, i+1, BLOCK_SIZE-i-2) &&  \\\n"
"		IN_RANGE(ty, i+1, BLOCK_SIZE-i-2) &&  \\\n"
"		IN_RANGE(tx, validXmin, validXmax) && \\\n"
"		IN_RANGE(ty, validYmin, validYmax) ) {\n"
"			computed = true;\n"
"			temp_t[ty][tx] =   temp_on_cuda[ty][tx] + step_div_Cap * (power_on_cuda[ty][tx] + \n"
"			(temp_on_cuda[S][tx] + temp_on_cuda[N][tx] - 2.0f * temp_on_cuda[ty][tx]) * Ry_1 + \n"
"			(temp_on_cuda[ty][E] + temp_on_cuda[ty][W] - 2.0f * temp_on_cuda[ty][tx]) * Rx_1 + \n"
"			(amb_temp - temp_on_cuda[ty][tx]) * Rz_1);\n"
"\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		\n"
"		if(i==iteration-1)\n"
"			break;\n"
"		if(computed)	 //Assign the computation range\n"
"			temp_on_cuda[ty][tx]= temp_t[ty][tx];\n"
"			\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	}\n"
"\n"
"	// update the global memory\n"
"	// after the last iteration, only threads coordinated within the \n"
"	// small block perform the calculation and switch on ``computed''\n"
"	if (computed){\n"
"	  temp_dst[index]= temp_t[ty][tx];		\n"
"	}\n"
"}\n"
;
